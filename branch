#!/bin/rc -e
rfork en
. /sys/lib/git/common.rc

gitup

flagfmt='a:listall, b:baseref ref, d:delete, n:newbr, s:stay, m:merge'
args='[branch]'
eval `''{aux/getflags $*} || exec aux/usage

modified=()
deleted=()

if(~ $#* 0){
	if(~ $#listall 0)
		awk '$1=="branch"{print $2}' < /mnt/git/ctl
	if not
		cd .git/refs/ && walk -f heads remotes
	exit
}
if(! ~ $#* 1)
	exec aux/usage

branch=$1
if(~ $branch refs/heads/*)
	new=$name
if not if(~ $branch heads/*)
	new=refs/$branch
if not
	new=refs/heads/$branch

if (~ $#baseref 1)
	base=`{git/query $baseref} || exit 'bad base'
if not if(test -e .git/$new)
	base=`{git/query $new}
if not
	base=`{git/query HEAD}

modified=`$nl{git/query -c HEAD $base | grep '^[^-]' | subst '^..'}
deleted=`$nl{git/query -c HEAD $base | grep '^-' | subst '^..'}

if(! ~ $#modified 0 || ! ~ $#deleted 0 && ~ $#merge 0){
	git/walk -fRMA $modified $deleted || 
		die 'uncommited changes would be clobbered'
}
if(~ $delete 1){
	rm -f .git/$new
	echo 'deleted branch' $new
	exit
}
if(~ $#newbr 0){
	if(! ~ $#baseref 0)
		die update would clobber $branch with $baseref
	baseref=`$nl{echo -n $new | sed s@refs/heads/@refs/remotes/origin/@}
	if(! test -e .git/$new)
		if(! base=`{git/query $baseref})
			die could not find branch $branch
}
commit=`{git/query $base} || die 'branch does not exist:' $base
echo updating $new to $commit

if(~ $new */*)
	mkdir -p .git/`{basename -d $new}

echo $commit > .git/$new


if(! ~ $#stay 0)
	exit

basedir=`{git/query -p $base}
cleanpaths=()
dirtypaths=()
if(! ~ $#modified 0 || ! ~ $#deleted 0){
	cleanpaths=`$nl{git/walk -cfT $modified $deleted}
	dirtypaths=`$nl{git/walk -cfRMA $modified $deleted}
}
for(m in $cleanpaths){
	d=`{basename -d $m}
	mkdir -p $d
	mkdir -p .git/index9/tracked/$d
	# Modifications can turn a file into
	# a directory, or vice versa, so we
	# need to delete and copy the files
	# over.
	a=`{test -f $m && echo file || echo dir}
	b=`{test -f $basedir/tree/$m && echo file || echo dir}
	if(! ~ $a $b){
		rm -rf $m
		rm -rf .git/index9/tracked/$m
	}
	if(test -f $basedir/tree/$m){
		cp  $basedir/tree/$m $m
		walk -eq $m > .git/index9/tracked/$m
	}
}
for(ours in $dirtypaths){
	common=/mnt/git/HEAD/tree/$ours
	theirs=/mnt/git/object/$base/tree/$ours
	n=$pid
	tmp=$ours.tmp
	while(test -f $tmp){
		tmp=$tmp.$n
		n=`{echo $n + 1 | hoc}
	}
	if(! test -f $ours)
		ours=/dev/null
	if(! test -f $theirs)
		theirs=/dev/null
	if(! test -f $common)
		common=/dev/null
	echo M $ours
	if(! ape/diff3 -m $ours $common $theirs > $tmp)
		echo '	'merge needed: $ours
	echo > .git/index9/tracked/$ours
	mv $tmp $ours
}
for(m in $localmods)
	echo > .git/index9/tracked/$m
if(! ~ $#deleted 0){
	rm -f $deleted
	rm -f .git/index9/tracked/$deleted
}

echo ref: $new > .git/HEAD
exit ''
